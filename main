package main

import (
  "fmt"
  "bat/fn"
  "sync"
  "time"
)
func main(){
  fn.Banner()
  fmt.Println("扫描开始，请耐心等待")
  
  //初始化一个长度为10的字符串切片，用于存储CIDR格式的网段
  cidrs:=make([]string,10)
  
  //获取网段ip
  cidrs=fn.Getlocalip()
  
  //定义一个用于存储ip的切片
  var allIPs []string

  //遍历每个cidr地址段
  for _,cidr:=range cidrs{
    //遍历每个CIDR地址段，使用GenerateIPs生成对应的ip地址列表
    ips,err:=fn.GenerateIPs(cidr)

    //错误处理
    if err!=nil{
      fmt.Println("Error:",err)
      continue
    }
    //将生成的ip地址追加到allIPs切片中
    allIPs=append(allIPs,ips...)
  }
  //定义一个WariGroup，用于等待所有goroutine完成
  var wg sync.WaitGroup
  //定义一个缓冲区通道，用于存储扫描结果。缓冲区大小是ip地址数量乘以默认端口
  results:=make(chan fn.ScanResult,len(allIPs)*len(fn.DefaultPorts))

  //记录扫描开始时间
  start:=time.Now()

  //遍历所有ip地址
  for _,ip:=range allIPs{
    //遍历默认端口列表，将端口发送到portsTask通道中，并在所有端口发送完后关闭通道
    portsTask:=make(chan int,len(fn.DefaultPorts))

    for _,port:=range fn.DefaultPorts{
      portsTask<-port
    }

    close(portsTask)

    //启动600个goroutine执行Scan函数，每个goroutine从portsTask通道中读取并进行扫描
    //扫描结果发送到results通道中。每个goroutine完成后调用wg.Done()
    for threads:=0;threads<600;threads++{
      wg.Add(1)
      go fn.Scan(ip,portsTask,results,&wg)
    }
  }
  //等待所有goroutine完成
  wg.Wait()
  //关闭结果通道，表示不再有新的扫描结果
  close(results)
  
  //生成报告文件
  fn.Savefile(results)

  //输出扫描结果信息
  fmt.Println("扫描报告已生成：result.html")
  fmt.Println("用时：",time.Since(start).String())
}
